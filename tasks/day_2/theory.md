1. Работа с пользовательскими структурами (повтор и углубление)

1.1. Переиспользование кода в Go (Packages)
•	Если вы в первый день создали пакеты (например, graph, stack, queue), вы можете их импортировать во второй день:

import (
"graph/graph"
"graph/stack"
"graph/queue"
)


	•	Помните, что имена, начинающиеся с заглавной буквы, экспортируются. Если хотите использовать, например, Graph из пакета graph, убедитесь, что структура названа Graph, а не graph.

1.2. Модульная организация
•	go.mod: указывает имя модуля, например module social_network/graph.
•	Папки:
•	graph/: graph.go (структура), bfs.go, dfs.go
•	day1/, day2/ … и т.п., в зависимости от структуры проекта.

2. Disjoint Set (Union-Find) — реализация “с нуля”

Во втором дне, для алгоритма Kрускала (или Борувки) (MST) (и/или динамического объединения компонент), вам понадобится Disjoint Set (Union-Find). 


Теперь мы переходим к продвинутым алгоритмам, и в этой первой полуторачасовой сессии второго дня займёмся подготовкой к MST (минимальному остовному дереву) и реализацией Disjoint Set (Union-Find).

1.1. Зачем нужна структура Disjoint Set (Union-Find)

При построении минимального остовного дерева (MST) (например, по алгоритму Крускала) мы:
* Сортируем все рёбра по возрастанию веса.
* Последовательно проходим рёбра от меньшего к большему:
  * Если ребро соединяет разные компоненты, мы включаем его в остов и объединяем компоненты.
  * Если ребро соединяет вершины одной и той же компоненты, пропускаем (иначе образуется цикл).
* Чтобы эффективно проверять, принадлежат ли две вершины одной компоненте, используется Disjoint Set (Union-Find).

Disjoint Set хранит множество непересекающихся «компонент». Для каждой вершины v мы можем быстро определить «корень» (representative). Если два элемента имеют один и тот же корень, они в одной компоненте.

1.2. Основные операции Union-Find
1.	MakeSet(v): инициализация (каждый элемент в своей компоненте).
2.	Find(v): найти корень (representative) компоненты, к которой принадлежит v.
      •	Обычно используется сжатие пути (path compression), чтобы ускорить повторные вызовы.
3.	Union(x, y): объединить компоненты, в которых находятся x и y.
      •	Чаще делают Union(Find(x), Find(y)).
      •	Применяют эвристику “union by rank/size”, чтобы подвешивать «меньшее дерево» к корню «большего».

1.3. В контексте «социального графа»
* Мы можем использовать Union-Find при формировании MST (например, для «минимального дерева дружбы»).
* Или, если нужно, динамически отслеживать компоненты при добавлении рёбер (дружб).

2.1. Объявление структуры

package unionfind

type DisjointSet struct {
parent []int
rank   []int
// или size []int, если хотите union by size
}

func NewDisjointSet(n int) *DisjointSet {
d := &DisjointSet{
parent: make([]int, n),
rank:   make([]int, n),
}
for i := 0; i < n; i++ {
d.parent[i] = i
d.rank[i] = 0
}
return d
}

	•	parent[i] хранит родителя элемента i. Изначально i — свой родитель.
	•	rank[i] (или size[i]): позволяет быстрее объединять деревья.

2.2. Методы Find и Union

func (d *DisjointSet) Find(x int) int {
if d.parent[x] != x {
d.parent[x] = d.Find(d.parent[x]) // path compression
}
return d.parent[x]
}

func (d *DisjointSet) Union(x, y int) bool {
rx := d.Find(x)
ry := d.Find(y)
if rx == ry {
return false // уже в одном множестве
}
// union by rank
if d.rank[rx] < d.rank[ry] {
d.parent[rx] = ry
} else if d.rank[rx] > d.rank[ry] {
d.parent[ry] = rx
} else {
d.parent[ry] = rx
d.rank[rx]++
}
return true
}

	•	path compression в Find экономит время (делает дерево плоским).
	•	Union возвращает true, если реально объединили, false, если уже одна компонента.

2.3. Применение
•	Для MST: сортируем рёбра, итерируем, делаем if ds.Find(u) != ds.Find(v) { ds.Union(u, v) ... }.
•	Для динамического объединения “дружб” в соцсети: при добавлении ребра (u,v) → Union(u,v).

6. Алгоритмы кратчайших путей (Dijkstra / Bellman-Ford)

6.1. Dijkstra (неотрицательные веса)
•	Свою MinHeap (см. выше) или линейный поиск min dist.
•	dist[u] = 0 для start, ∞ для остальных.
•	Извлекаем вершину u c min dist, релаксируем ребра (u->v).
•	Сложность: ￼ с heap, либо ￼ при линейном поиске.

6.2. Bellman-Ford
•	Не требует кучи, зато работает при отрицательных весах (без отриц. циклов).
•	dist[start]=0, остальным ∞.
•	Проходим V-1 раз по всем рёбрам (u,v,w), релаксируем.
•	Если на V-м проходе есть улучшение – отрицательный цикл.

7. Горрутины и каналы (распределённая модель)
   •	Во втором дне вы можете начать подключать параллельность (например, параллельную сортировку), но это будет нужно на дне 3–5, когда начнем выполнение выборов лидера, Raft, MapReduce.
   •	Если всё же хотите параллельно запустить MST/DFS (каждый фрагмент), используйте go func() + канал для сбора результатов.

8. Рекомендации по Go-стилю и отладке
    1.	Именование:
          •	Используйте CamelCase, например func BFS(...), func Dijkstra(...).
          •	Экспортируемое — с заглавной буквы, внутреннее — со строчной.
    2.	Логирование:
          •	fmt.Println() для отладочных сообщений.
          •	Можно завести debug bool, чтобы управлять verbosity.
    3.	Тесты:
          •	Минимум “ручных” в main, можно сделать *_test.go файлы.
          •	Запуск go test ./...
