Ниже представлены задания второго дня:

**Задание 1. Реализовать структуру DisjointSet (Union-Find)**
1. Создайте файл unionfind.go.
2. Определите структуру:
    ```go
    type DisjointSet struct {
        parent []int
        rank []int 
	    // или size []int — по желанию
    }
    ```
3. Функция NewDisjointSet(n int) \*DisjointSet:
    * Создаёт массив parent размером n, где parent[i] = i (каждый элемент — свой собственный корень).
    * Инициализирует rank[i] = 0 (или size[i] = 1).
4. Find(x int) int:
    * Если parent[x] != x, делаем parent[x] = Find(parent[x]) (сжатие пути).
    * Возвращаем parent[x].
5. Union(x, y int) bool:
    * Находим rx = Find(x), ry = Find(y).
    * Если rx == ry, вернуть false (уже в одной компоненте).
    * Иначе сравнить rank[rx] и rank[ry], подвесить дерево меньше ранга к большему. Если ранги равны, rank увеличиваем у нового корня.
    * Вернуть true (успешно объединили).

**Задание 2. Расширить структуру Graph для хранения весов**
1. Сейчас у нас Graph.adj[u] = []int для хранения соседей без учёта весов.
2. Нужно для MST иметь **веса**.
    * **Вариант A**: Хранить отдельно список рёбер edges []Edge, где type Edge struct { u, v, w int }. Тогда MST будет работать на этом списке, а Graph по-прежнему нужен только для смежности.
    * **Вариант B**: Хранить adj[u] как срез структур { to, weight }.
3. Для **Крускала** удобен **Вариант A** — просто собирать все рёбра, а потом сортировать их.

**Задание 3. Реализовать сбор рёбер из графа**
1. Создайте функцию (если выбрали Вариант A):
```go
func (g *Graph) GetAllEdges() []Edge {
    var edges []Edge
    // Пройти по каждой вершине u
    // по каждому соседу (v, w)
    // если (u < v), чтоб не дублировать в неориент. графе
    // edges = append(edges, Edge{u, v, w})
    return edges
}
```
2. Не забудьте, что у вас должна быть информация о весах. Если её нет в adj, можно пока вручную формировать список рёбер, когда вводите данные.

**Задание 4. MST**
1. Создайте файл mst.go.
2. Определите функцию:
    ```go
    func MST(n int, edges []Edge) (mst []Edge, totalWeight int)
    ```
   * Здесь n — количество вершин, edges — список всех рёбер (u, v, w).
   * Сортируем edges по w (пишем алгоритм сортировки quicksort/mergesort).
   * Создаём ds := NewDisjointSet(n).
   * Идём по отсортированным рёбрам:
       * if ds.Find(u) != ds.Find(v) { ds.Union(u, v); mst = append(mst, edge); totalWeight += w; }
       * Если len(mst) == n-1 → break.

3. Возвращаем (mst, totalWeight).

**Задание 5. Расширить хранение весов**
1. Если вы уже хранили рёбра для MST ([]Edge), то используйте ту же структуру для алгоритмов кратчайшего пути:
    * Для Dijkstra/Bellman-Ford удобнее иметь список рёбер (Bellman-Ford) и cписки смежности (Dijkstra).
2. Допишите метод GetNeighbors(u int) []struct{ v, w int } для ориентированных или неориентированных рёбер.
3. Убедитесь, что ваши данные «дружбы»/весов в «социальном графе» корректно заданы.

**Задание 6. Реализовать Dijkstra**
1. Создайте файл dijkstra.go.
2. Объявите функцию:
    ```go
    func Dijkstra(g *Graph, start int) ([]int, []int) {
    // возвращаем dist[] и parent[] (или просто dist[])
    }
    ```
3. Способы найти вершину с мин. расстоянием:
* **Вариант A**: Сделать свою **PriorityQueue** (MinHeap):
    * type PriorityQueue struct { items []Item }
    * type Item struct { vertex, dist int }
    * Методы Push(...), Pop(), heapifyUp(), heapifyDown().
* **Вариант B**: Линейный поиск минимума в массиве dist, где visited[v] == false, за O(V). Тогда общее O(V^2).
4. Инициализируем dist[v] = ∞, dist[start] = 0, parent[v] = -1.
5. Пока есть непосещённые вершины:
    * Находим u c min(dist[u]) среди непосещённых.
    * Помечаем u посещённой.
    * Для каждого соседа w вершины u: если dist[u] + weight(u,w) < dist[w], то обновляем dist[w], parent[w] = u.
6. Возвращаем dist, parent.

**Задание 7. Bellman-Ford**
1. **Нужно** поддержать отрицательные веса, для этого создаём:
    ```go
    func BellmanFord(g *Graph, start int) ([]int, []int, bool) {
    // bool означает "есть ли отрицательный цикл?"
    }
    ```
2. Инициализация: dist[start] = 0, остальным = ∞.
3. Цикл for i in 1..(V-1):
    * Проход по всем рёбрам (u, v, w):
    * если dist[u] + w < dist[v] → обновить.
4. Отдельный проход для проверки отриц. цикла: если улучшение ещё возможно → цикл.
5. Вывести результат (или negativeCycle = true).

**Задание 8. Демонстрация работы**
1. Создайте day2_main.go.
2. Инициализируйте DisjointSet на n = 6.
3. Вызывайте Union(0,1), Union(1,2), Union(3,4).
4. Напечатайте результат (корни Find(0), Find(1), …).
5. Убедитесь, что 0,1,2 лежат в одной компоненте, 3,4 — в другой, а 5 — сам по себе.
6. Попробуйте Union(2,3), теперь 0..4 окажутся в одной компоненте.
7. Выведите parent[], rank[].
8. Соберите список edges.
9. Вызовите MST(len(вершин), edges).
10. Выведите результат:
    • Список рёбер MST, их суммарный вес totalWeight.
11. Сравните, действительно ли он «минимальный» (посчитайте вручную, если небольшой).
12. Инициализируйте небольшой **взвешенный** граф (5–6 вершин, rёбер с разными весами).
    * Вызовите Dijkstra(g, start), выведите dist[].
    * Если у вас есть отриц. вес, используйте BellmanFord(g, start).
    * Сравните результаты.
