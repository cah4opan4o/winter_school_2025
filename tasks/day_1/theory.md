Для нашей будущей «распределённой системы социального графа» нам понадобятся фундаментальные структуры:
1. Массивы и срезы (array, slice)
* Массив [N]T в Go имеет фиксированную длину и передаётся по значению (копией).
* Срез []T (slice) — динамическая структура, ссылается на подлежащий массив, может изменяться по длине len и вместимости cap.
* В данном блоке мы будем использовать срезы как основу для реализации «списка», «очереди», «стека» и т.п.
2. Связные списки (linked list)
3. Очередь (FIFO) и Стек (LIFO) — из срезов
* Очередь: можно реализовать как срез с «головой» (индекс начала) и «хвостом» (индекс конца). При добавлении (enqueue) увеличиваем хвост, при извлечении (dequeue) увеличиваем голову.
* Стек: ещё проще — push и pop работаем с концом среза.
4. Множество (Set) и Словарь (Map) — встроенный map в Go
      •	Используем встроенный map (для ключ-значение) и make(map[ТипКлюча]ТипЗначения).

### Начало «социального графа»

В сценарии нашего «Распределённого социального графа»:
* Граф хранит пользователей (вершины) и «дружбу» (рёбра).
* Пока не будем углубляться в распределённость; важно научиться хранить этот граф в одной программе.

Способы хранения
1. Список смежности (adjacency list):
* Для каждой вершины (пользователя) хранится срез ID-шников друзей.
  * Например, graph[u] = []int{…}, где u — это ID пользователя, а в массиве — его «друзья».
  * Подходит, если граф потенциально разреженный (не все со всеми дружат).
2. Матрица смежности (adjacency matrix):
   * matrix[u][v] = true, если u дружит с v; иначе false.
   * Подходит для небольших, но плотных графов. В большом социальном графе размер V может быть huge → матрица станет слишком громоздкой.

В большинстве «больших систем» используют список смежности.

### Организация Go-проекта

go.mod – хранит имя модуля и версии зависимостей. Для учебного проекта часто достаточно:
```shell
go mod init social-graph
```
и затем go mod tidy при необходимости.

1. Структура: можно разбивать на папки (например, graph/, distributed/, cmd/), либо всё хранить в одном месте, подключая файлы друг к другу.
2. Сборка и запуск:
    ```shell
    run main.go
    build -o app main.go && ./app
    ```
3. Файлы:

    *.go файлы, внутри – пакет (package main для исполняемого, package graph или любое другое для библиотечных частей).

### Базовый синтаксис Go

1. Переменные и базовые типы
```go
var x int         // объявление x как int
var y = 10        // объявление + инициализация
z := 20           // короткая форма в функции

var s string = "hello"
var f float64 = 3.14
var b bool = true
```
* Массив [N]T: фиксированный размер. Передаётся копией.
* Срез []T: динамический, “view” на подлежащий массив.

2. Управляющие конструкции
* if, for, switch.
* Нет while, всё делается через for.
```go
for i := 0; i < 5; i++ { ... }
for x < 100 { ... } // "while"
for { ... } // бесконечный
```
* switch:
```go
switch val {
    case 1: ...
    case 2,3: ...
    default: ...
}
```
3. Функции и структуры

   1. Функции
    ```go
    func add(a, b int) int {
        return a + b
    }
    func doSomething(s string) (string, bool) {
        if s == "" {
            return "empty", false
        }
        return s, true
    }
    ```
   * Аргументы по значению. Если нужно менять объект, передаём *T.
   
   2. Структуры (struct)
    ```go
    type User struct {
        ID   int
        Name string
    }

    func NewUser(id int, name string) *User {
        return &User{ID: id, Name: name}
    }
    ```
   * Методы:
    ```go
    func (u *User) GetName() string {
        return u.Name
    }
    ```
   
   3. Интерфейсы

    ```go
    type Stringer interface {
        String() string
    }
    ```
	* Любой тип, имеющий метод String() string, удовлетворяет Stringer.

4. Работа с slice и map вместо готовых контейнеров

   1. Срез (slice)
   * Создание:
    ```go
    s := []int{1,2,3}
    s2 := make([]int, 0, 10) // длина 0, вместимость 10
    ```
	* Операции:
    ```go
    s = append(s, 4,5)
    sub := s[1:3] // полуоткрытый диапазон
    ```
	* Внимание: при удалении первого элемента s = s[1:] – это оставляет в памяти ту же подложку, но смещённый view.

   2. Карта (map) – встроенная хеш-таблица
    ```go
    m := make(map[int]string)
    m[1] = "Alice"
    name, ok := m[1]
    if ok { ... }
    delete(m, 1)
    ```
	* Пригодится для хранения вершин id -> data.

5. Создание собственных структур
   1. Стек (Stack)
```go
type Stack struct {
	data []int
}

func NewStack() *Stack {
    return &Stack{data: make([]int, 0)}
}

func (s *Stack) Push(x int) {
    s.data = append(s.data, x)
}
func (s *Stack) Pop() (int, bool) {
    if len(s.data) == 0 {
        return 0, false
    }
    topIndex := len(s.data) - 1
    val := s.data[topIndex]
    s.data = s.data[:topIndex]
    return val, true
}
func (s *Stack) IsEmpty() bool {
    return len(s.data) == 0
}
```

5.2. Очередь (Queue)
```go
type Queue struct {
    data []int
    head int
    tail int
}

// или упрощённо:
type SimpleQueue []int

func (q *SimpleQueue) Enqueue(x int) {
    *q = append(*q, x)
}
func (q *SimpleQueue) Dequeue() (int, bool) {
    if len(*q) == 0 {
        return 0, false
    }
    val := (*q)[0]
    *q = (*q)[1:]
    return val, true
}
```

6. “Социальный граф”: пример структуры Graph
   1. Базовая форма
```go
type Graph struct {
    // Список смежности
    adj map[int][]int
    // При необходимости хранить веса:
    // edges []Edge
}

func NewGraph() *Graph {
    return &Graph{adj: make(map[int][]int)}
}

func (g *Graph) AddEdge(u, v int, undirected bool) {
    g.adj[u] = append(g.adj[u], v)
    if undirected {
        g.adj[v] = append(g.adj[v], u)
    }
}
```

7. Обход в ширину (BFS)
* Назначение: в невзвешенном графе (каждое ребро «равноценно») найти:
  * Минимальное количество рёбер от вершины s до каждой другой достижимой вершины.
  * «Слои» вершин по расстоянию от s.
* Принцип:
  1.	Заводим очередь (FIFO).
  2.	Помечаем dist[s] = 0, visited[s] = true.
  3.	Кладём s в очередь.
  4.	Пока очередь не пуста:
     * Извлекаем вершину u.
     * Для всех её соседей v, если v не посещён:
       * dist[v] = dist[u] + 1
       * visited[v] = true
       * добавляем v в очередь.
* Срез + методы:
  * Можно использовать type Queue struct { data []int }, с методами Enqueue, Dequeue.
  * Или “простейший” вариант: var queue []int; append(queue, item) и удалять первый элемент.

8. Обход в глубину (DFS)
* Назначение:
  * Находим «глубинное» прохождение по графу.
  * Полезно для выделения компонент связности, поиска циклов, т.д.
  * Принцип (рекурсия):
    ```go
    func DFS(g *Graph, v int) {
        visited[v] = true
        for each neighbor u of v {
            if !visited[u] {
                DFS(g, u)
            }
        }
    }
    ```
  * Итеративный вариант (через стек):
    1. Имеем stack, кладём туда v.
    2. Пока не пусто:
       * pop вершину curr;
       * если curr не посещён — пометить как посещён;
       * в stack положить всех непосещённых соседей.
    3. Срез + методы:
       * type Stack struct { data []int }
       * Push(x), Pop() (int, bool), IsEmpty() bool.

9. Применение BFS/DFS к «социальному графу»
В рамках сценария соцсети:
* BFS:
  * Можно определить «минимальное число рёбер-дружбы» между пользователями A и B.
  * Пример: «Сколько нужно «прыжков» от A до B?»
* DFS:
  * Проверить, есть ли единая компонента (все ли пользователи связаны через цепочки друзей?), или их несколько?
  * Найти, существуют ли «циклы» (в обычном неориентированном графе все рёбра, кроме мостов, будут цикл создавать, но в учебной задаче можно искать компоненты и т.д.).

10. Полезные Go-советы
    1.	Форматирование: go fmt или используйте autoformat в IDE, чтобы код выглядел “по-Go-шному”.
    2.	Ошибки: нет исключений, возвращают error (или bool) из функций.
    3.	Именование: Заглавная буква – экспорт, строчная – приватно в пакете.

