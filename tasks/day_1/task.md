Ниже представлены задания первого дня:

**Задание 1. Реализация вспомогательных структур**
1. **Реализовать Стек**:
    * Тип type Stack struct { data []int }.
    * Методы Push(x int), Pop() (int, bool), IsEmpty() bool.
    * Используйте срез data []int.
2. **Реализовать Очередь**:
    * Тип type Queue struct { data []int; head, tail int } или проще type Queue []int.
    * Методы Enqueue(x int) / Dequeue() (int, bool).

**Задание 2. Создать простую структуру Graph**
1. Напишите type Graph struct { adj map[int][]int }.
2. Функцию NewGraph() *Graph.
3. AddEdge(u, v int):
    * Для неориентированного графа дублировать в обе стороны.
    * Если ключ u ещё не существует, инициализируйте пустой slice []int.

**Задание 3. Простая проверка «дружбы»**
1. Функция HasEdge(g *Graph, u, v int) bool: вернуть true, если v есть в g.adj[u].
    * Линейный поиск по g.adj[u] (без готовых «in set»).
2. Протестировать на маленьком графе (3–4 пользователя).

**Задание 4. Реализовать BFS для Graph**
1. Используем уже готовые:
    * Graph (с adj map\[int\]\[\]int).
    * Queue (или самый простой slice).
2. Написать функцию:
```go
func BFS(g *Graph, start int) []int {
// возвращает список вершин в порядке обхода
}
```
* Инициировать visited := make(map[int]bool) или []bool (если вершины — 0..N-1).
* Заводим очередь, кладём start.
* Пока очередь не пуста, извлекаем u, добавляем в “порядок обхода” (order = append(order, u)).
* Для каждого соседа v проверяем, если не посещён — ставим visited[v] = true, enqueue(v).
* Возвращаем order.

**Задание 5. Реализовать DFS (рекурсивный или итеративный)**
1. Функция:
```go
func DFS(g *Graph, start int) []int {
// возвращает список вершин в порядке обхода
}
```
2. Вариант A (рекурсия):
```go
func (g *Graph) dfsUtil(v int, visited map[int]bool, order *[]int) {
    visited[v] = true
    *order = append(*order, v)
    for _, u := range g.adj[v] {
        if !visited[u] {
            g.dfsUtil(u, visited, order)
        }
    }
}

func DFS(g *Graph, start int) []int {
    visited := make(map[int]bool)
    var order []int
    g.dfsUtil(start, visited, &order)
    return order
}
```
3. Вариант B (итеративно, стек):
    * Подключаем Stack.
    * Логика схожа с BFS, только LIFO.

**Задание 6. Проверка корректности**
1. Создайте/заполните **простой граф** (5–6 вершин, несколько рёбер).
2. Запустите BFS(g, 0) и DFS(g, 0) — выведите порядок обхода:
    * «Порядок обхода BFS: …»
    * «Порядок обхода DFS: …»
3. Убедитесь, что BFS идёт «по слоям», DFS — «в глубину».

**Задание 7. Функция ConnectedComponents()**
1. Создайте функцию:
```go
func ConnectedComponents(g *Graph) (count int, comp map[int]int) {
// comp[v] = номер компоненты (1..count)
}
```
2. **Реализация**:
* Завести visited := make(map[int]bool).
* comp := make(map[int]int) для записи, к какой компоненте относится вершина.
* count = 0
* Для **каждой** вершины v (ключ в g.adj), если !visited\[v\]:
    * count++
    * Запустить DFS (или BFS) от v.
        * Все достигнутые вершины u пометить visited[u] = true, comp[u] = count.
3. **Вернуть** (count, comp).

**Задание 8. Проверить на примере**
1. Создайте “разорванный” пример:
    * Допустим, вершины 0..6, где (0..3) образуют одну связную группу, а (4..6) другую, и, например, 2..3 нет ребра.
2. Вызовите ConnectedComponents(g).
3. Выведите count и, для каждой вершины, номер компоненты comp[v].
4. Убедитесь, что алгоритм правильно выделил 2 компоненты.

**Задание 9. Main-файл для демонстрации**
Создайте файл day1_main.go в папке cmd, где:
1. Импортируйте (или подключите) graph.go, queue.go, stack.go, bfs.go, dfs.go
2. Инициализируете новый граф: g := NewGraph().
3. Добавляете несколько рёбер (пользователей).
4. Выводите структуру (например, fmt.Println(g.adj)).
5. Проверяете 1–2 «дружбы» через HasEdge.
6. Вызов BFS(g, start), вывод результата.
7. Вызов DFS(g, start), вывод результата.
8. Сконструировать граф с несколькими «островами».
9. Вызвать ConnectedComponents(g), вывести результат.