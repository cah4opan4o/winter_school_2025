# Распределённая система социального графа

Представим, что мы создаём распределённую социальную сеть, где:
1. Есть большой граф пользователей (вершины – пользователи, рёбра – “дружба”).
2. Каждая “дружба” может иметь “вес” (например, “близость”, “количество общих интересов” или что-то подобное).
3. Храним и обрабатываем посты (текст), осуществляем поиск и различные агрегирующие задачи (MapReduce).
4. Система распределена на многие узлы (горутины), требуется механизм лидера для координации, а также консенсус для согласования важных действий (например, согласованная запись в общий лог).

## Что нам понадобится из алгоритмов:

### 1. Структуры данных и обходы графов (BFS, DFS)

**Задача**: Нам нужно, к примеру, быстро находить группу друзей и степень связности.
* **DFS**:
    * Определение компонент связности (если граф не полностью соединён).
    * Выявление “островков” пользователей.
* **BFS**:
    * Поиск минимального числа “шагов дружбы” от одного пользователя к другому (в невзвешенном случае).
    * Функция “показать друзей в радиусе 2–3 переходов”.
      В коде:
      * Храним сеть в виде списка смежности.
      * Используем **BFS**/**DFS**, чтобы для заданного пользователя быстро найти:
          * Всех достижимых “друзей”.
          * Различные “расстояния по рёбрам” (количество шагов).

### 2. Элементарные структуры данных

**2.1 Хеш-таблицы и префиксные деревья (tries)**
* **Хеш-таблицы**:
    * Для быстрого доступа к профилям пользователей по их ID.

* **Префиксное дерево (trie)**:
    * Хранение “корзины слов” для каждого поста (поисковые фразы).
    * Быстрый поиск по префиксу (например, автодополнение при вводе “имён друзей” или “тегов” в соцсети).

(Более сложные деревья (**_B-дерево_** _или_ **_красно-чёрное дерево_**) можно применять для индексации документов/постов по дате или для хранения статистических структур.)

### 3. Сортировки и кратчайшие пути

**3.1 Сортировка**
* **Quick Sort / Merge Sort**:
    * Сортируем массив постов по времени или массив “рёбер” по какому-то признаку.
    * Если нужно найти “top-K” пользователей по какому-то критерию, внутренняя сортировка пригодится.

**3.2 Алгоритмы кратчайшего пути (Dijkstra / Bellman-Ford)**
* Переходим к взвешенной модели дружбы (рёбрам присвоен вес, например, “близость”).
* **Dijkstra**:
    * Найти пользователя, с которым у нас “максимальная близость”/“минимальная дистанция” по сумме весов.
    * В неотрицательной сети “дружбы” – Dijkstra отлично подходит.
* **Bellman-Ford** (если вдруг есть “отрицательные веса” ).
* Или **Floyd-Warshall**, если хотим все пары расстояний (полный обзор пути между любыми двумя пользователями).

### 4. Остовные деревья (MST)
В соцсети мы можем задействовать это, например, для:
* “Минимальная связь” среди подгруппы. Если нам нужно “связать” всех пользователей клуба минимальным “суммарным весом” дружбы, MST (Крускал/Прим/Борувки) может помочь.
* Или следующая задача: построить “скелет” связей, по которым можно “транслировать” информацию, минимизируя общий “вес” прохождения.

### 5. Распределённые алгоритмы

**5.1 Выбор Лидера (Bully или Ring)**
* У нас есть кластер серверов (для абстракции представления воспользуемся горутинами), обрабатывающих соцсеть.
* При сбое ведущего узла – мы запускаем **алгоритм выбора лидера**:
    * **Bully** (у каждого узла уникальный ID; узел с максимальным ID “побеждает”).
    * **Ring-based** ( Chang–Roberts ), если мы логически расположим узлы в кольцо.

**5.2 Консенсус (упрощённый Raft / Paxos)**
* Для согласованного логирования важных событий:
    * Каждый узел получает новые “транзакции” (например, user A обновил профиль) – нужно согласовать, что все узлы в кластере применили это изменение в едином порядке.
* **Raft (лайт версия)**:
    * Лидер (выбранный по Raft) принимает записи, рассылает их фолловерам, добивается “мажорного” подтверждения.
    * При сбоях – переизбрание.

**5.3 MapReduce (упрощенная версия) для больших данных**

Например, для задачи подсчета количества слов, алгоритм можно применить в следующем виде:
* Собираем (генерируем) огромный лог постов.
* **Map**: разбить текст на слова, выдавая (слово, 1).
* **Reduce**: суммировать количество для каждого слова → “WordCount”.
* Или более специфическая аналитика (например, подсчитать самые частые хэштеги).

Распределённость:
* Каждый узел кластера хранит часть данных, запускает Map локально.
* Потом “shuffle” (слова -> распределение по ключам) и Reduce агрегирует.

## Вид итогового проекта

Таким образом, реализация проекта ожидается в следующем виде:
1. **Храним** соцграф в самописных структурах (списки, например).
2. Применяем **BFS/DFS** для поиска друзей / компонент.
3. Там, где нужно – **MST** (например, “скелет дружбы”).
4. **Dijkstra** для взвешенных путей (самый короткий / самый сильный “канал” дружбы).
5. **Хеш-таблицы** и/или **префиксные деревья** (trie) для хранения/поиска контента (постов, пользователей).
6. **Распределённость**: имеем несколько “узлов”-процессов (goroutines):
    * Выбираем **лидера** (Bully / Ring).
    * Для атомарной согласованной записи (консенсус) – упрощённый **Raft**.
    * **MapReduce**-задачи для анализа данных.
7. Всё это оформляем в виде отдельных **этапов** (по дням), но внутри одного “сквозного” проекта.

В итоге каждый алгоритм находит **реальное применение**:
* **Обходы графа**: поиск соседей, друзей, проверки связности.
* **Сортировки** / **MST** / **Union-Find**: дополнительная аналитика над группой.
* **Кратчайший путь**: “наименьшее число кликов” или “максимальная близость”.
* **Структуры (hash, trie)**: для быстрых lookup-операций по ID, для автодополнения слов.
* **Распределённые алгоритмы**: система работает из нескольких узлов, нужен лидер, нужно соглашаться на одну последовательность апдейтов (консенсус), большие агрегаты идут через MapReduce.

Задания по каждому дню вы найдете по следующим ссылкам:
1. [Перейти к заданиям первого дня](./day_1/task.md)
2. [Перейти к заданиям второго дня](./day_2/task.md)
3. [Перейти к заданиям третьего дня](./day_3/task.md)
4. [Перейти к заданиям четвертого дня](./day_4/task.md)
5. [Перейти к заданиям пятого дня](./day_5/task.md)